# Add Post type to Prisma
* **note** The datamodel.prisma file is very important!

## Prisma using datamodel.prisma to:
1. Determine the DB structure

* We have a user type here:

`datamodel.prisma`

```
type User {
  id: ID! @id
  name: String!
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}
```

* We have a user type in our postgres db that we can see through `pgAdmin`

## Local GraphQL Playground
* localhost:4466

## Schema in GraphQL Playground
* You will only see `users` because that is the only type we currently have defined
    - This was automatically generated by the default prisma project
    - We will use this but we need to add some fields

## We'll first focus on our scalar fields from our Basic GraphQL
`graphql-basics/src/schema.graphql`

```
type User {
  id: ID!
  name: String!
  email: String!
  age: Int
  posts: [Post!]!
  comments: [Comment!]!
}
```

### Add email to our prisma file
```
type User {
  id: ID! @id
  name: String!
  email: String!
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}
```

* We'll ditch `age`, `posts` and `comments` for now
* We'll keep `id`, `name` and `email`
* If we define other types we will then see them here

### Re-run prisma deploy

`$ prisma deploy`

#### Is docker running?
* Start docker on your Mac
* Search for it in Application and run it

![run Docker](https://i.imgur.com/HcukFEw.png)

* Make sure you get the green docker icon

![green docker running icon](https://i.imgur.com/HTZZOsw.png)

`$ docker-compose up -d` and `$ prisma deploy`

* Now after you save your changes by adding email you will see this after deploying

![new email field added](https://i.imgur.com/Tg3uIHv.png)

* Open docs and you will now see the new `email` field added to your self-generating documentation

![new email](https://i.imgur.com/tOtm2In.png)

* When we re-run `$ prisma deploy` it will read the contents of `datamodel.prisma` and it will update both the DB structure and the GraphQL API to work with this brand new field

## Error
* You will receive `You are creating a required field but there are already nodes present that would violate that constraint`

![error required fields](https://i.imgur.com/1jacFgV.png)

* We added a required field `email: String`
    - `nodes` are the rows of data we already have that don't have an email because when we created them before it didn't exist
    - **note** If you didn't have `pgAdmin` running, you may not get this error (_you may have to remove the email field, deploy again, then add it and deploy again and you should then see the error_)
    - Delete the users in your user table so the table is empty
* Our previous GraphQL `createUser` mutation will no longer work because email is now required and if we try to run:

```
mutation {
  createUser(data: {
    name: "Clyde"
  }) {
    id
    name
  }
}
```

* We will get this error

```
{
  "data": null,
  "errors": [
    {
      "message": "Argument 'data' expected type 'UserCreateInput!' but got: {name: \"Clyde\"}. Reason: 'email' Not-null field 'email' of type 'String!' defined in the 'UserCreateInput' input type is missing. (line 2, column 20):\n  createUser(data: {name: \"Clyde\"}) {\n                   ^",
      "locations": [
        {
          "line": 2,
          "column": 20
        }
      ]
    }
  ]
}
```

* Update the `createUser` GraphQL Mutation with:

```
mutation {
  createUser(data: {
    name: "Clyde",
    email:"clyde@clyde.com"
  }) {
    id
    name
  }
}
```

* You should get a successful response

```
{
  "data": {
    "createUser": {
      "id": "cjwzhn0kv006v0700b3cv7ank",
      "name": "Clyde"
    }
  }
}
```

![user in DB](https://i.imgur.com/Y3zQPZ9.png)

* Show all available fields

```
mutation {
  createUser(data: {
    name: "Clyde",
    email:"clyde@clyde.com"
  }) {
    id
    name
    email
  }
}
```

* Response now shows `email`

```
{
  "data": {
    "createUser": {
      "id": "cjwzhq3be007v0700g6v6kngv",
      "name": "Clyde",
      "email": "clyde@clyde.com"
    }
  }
}
```

## @unique
* This is a GraphQL directive
    - What is a directive?
        + A way to modify the behavior of the field
        + Most of the type we usually will first create the directive and then use it
            * But we did not create `@unique` and this is because prisma created this for us
            * Prisma provides us with pre-created stuff to make our lives easier
                - Prisma gives us:
                    + Custom types
                    + Directives
                    + More...

### What does the `@unique` directive do?
* It makes sure a given field is unique

### What is the direcive syntax
`id: ID @DIRECTIVE_NAME_HERE`

```
type User {
  id: ID! @unique

// MORE CODE
```

#### Error @unique or @id
* You will get this error:

`One field of the type `User` must be marked as the id field with the "@id" directive.`

* You need to replace `@unique` with `@id`

`datamodel.prisma`

```
type User {
  id: ID! @id
  name: String!
  email: String! @unique
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}
```

* Save and re-deploy

`$ prisma deploy`

* Output in terminal will be:

```
Deploying service `default` to stage `default` to server `local` 11.5s

Changes:

  User (Type)
  ~ Updated field `email`. It became unique.

Applying changes 37.4s

Your Prisma endpoint is live:

  HTTP:  http://localhost:4466
  WS:    ws://localhost:4466

You can view & edit your data here:

  Prisma Admin: http://localhost:4466/_admin
```

### Test out @unique
* Enter same `email` we used before and it should fail because it is not unique

#### We get an error
* You will see an error like this:

```
{
  "data": null,
  "errors": [
    {
      "locations": [
        {
          "line": 2,
          "column": 3
        }
      ],
      "path": [
        "createUser"
      ],
      "code": 3010,
      "message": "A unique constraint would be violated on User. Details: Field name = email",
      "requestId": "local:cjwzz9dwb01fo0700x3c8klzx"
    }
  ]
}
```

## Set up the Post type
`datamodel.prisma`

* These are all the fields with scaler types 

```
// MORE CODE

type Post {
  id: ID! @id
  title: String!
  body: String!
  published: Boolean!
}
```

### Now we'll set up relationships
* We can't set up the comments relationship because the `Comment` type doesn't exist yet

`datamodel.prisma`

```
type User {
  id: ID! @id
  name: String!
  email: String! @unique
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
  posts: [Post!]!
}

type Post {
  id: ID! @id
  title: String!
  body: String!
  published: Boolean!
  author: User!
}
```

* Save and re-deploy

`$ prisma deploy`

```
Changes:

  Post (Type)
  + Created type `Post`
  + Created field `id` of type `ID!`
  + Created field `title` of type `String!`
  + Created field `body` of type `String!`
  + Created field `published` of type `Boolean!`
  + Created field `author` of type `User!`

  User (Type)
  + Created field `posts` of type `[Post!]!`

  PostToUser (Relation)
  + Created an inline relation between `Post` and `User` in the column `author` of table `Post`
```

* Now we create a `Post` type and all it's fields
* A field on User called `posts`
* A new type called `PostToUser` that holds a relation

**note** The relationship has been moved to indexes in newer Prisma versions!
* Old prisma created an `_PostToUser` table and `_RelayId table`

## Review GraphQL Playground
* **note** All of the following were autogenerated based on our 8 lines we added to our `datamodel.prisma`

### Stuff we just added automatically!
* Now there are Queries for `post` and `posts`
* CRUD for Posts
* We have one new post subscription

## Time to create a post
* We review the documentation

```
type PostCreateInput {
    id: ID
    title: String!
    body: String!
    published: Boolean!
    author: UserCreateOneWithoutPostsInput!
}
```

* We expect to get a `Post` back (we get back the new post we create)
* But when it comes to the `data` Argument
    - We see we have `title`, `body` and `published` as expected
    - But we also have **author** and this is where we set up the **relationship**
    - So all posts have to have an author that wrote them so we need to set up this relationship when setting up a post (just as we did before)

```
type UserCreateOneWithoutPostsInput {
    create: UserCreateWithoutPostsInput
    connect: UserWhereUniqueInput
}
```

* We see it results in either creating a new user when we create this post or connecting it to an existing user
    - We will use connect to connect it to an existing user

```
type UserWhereUniqueInput {
    id: ID
    email: String
}
```

* We can connect it to anything that makes the user unique (so `id` or `email`)

## Copy the id of a user you created
* Find in GraphQL or pgAdmin

## Create a new post
* GraphQL

```
mutation {
  createPost(
    data: {
      title: "1986 World Cup"
      body: "Argentiana Wins"
      published: false
      author: { connect: { id: "cjx00qd8l008a0859zfb31bhw" } }
    }
  ) {
    title
    body
    published
    author {
      id
      name
    }
  }
}
```

* Response

```
{
  "data": {
    "createPost": {
      "title": "1986 World Cup",
      "body": "Argentiana Wins",
      "published": false,
      "author": {
        "id": "cjx00qd8l008a0859zfb31bhw",
        "name": "Clyde"
      }
    }
  }
}
```

* View pgAdmin and you will see

![table row of Posts](https://i.imgur.com/J4xpbPT.png)

* If this seems like a bit much to provide author the `id`, it would be something if there were something like `author_id`
* Don't worry about this as we won't be making any GraphQL API requests from GraphQL PlayGround
    - Instead we'll be using a tool that makes this easier when it comes to interacting with Prisma from Node.js



