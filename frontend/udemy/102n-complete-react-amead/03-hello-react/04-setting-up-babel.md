# Setting up Babel
* Babel does nothing by default
* To get it to work we have to add:
    - presets
    - configs

## What is a Babel preset?
* A group of plugins

![babel presets](https://i.imgur.com/RJCSMWT.png)

### Remove the react preset on babeljs.io
* Uncheck `react` preset and we get an error because without React preset babel won't understand JSX
    - So we will need to install the `React` preset locally to get `babel` to transpile
    - That will take our JSX and convert it into `React.createElement()` function calls that browser understand

### [learn about presets](http://babeljs.io/docs/plugins/)
* This is the babel js docs plugins page
* This list is the **Official Presets**
    - We will use 2 presets

1. `react`
2. `env`

#### 1. react preset
* If you click the **react preset** you will see all the plugins it uses
    - It would take time to individually install all those plugins
    - It is faster and easier to just install a **preset** that _comes bundled with all of those plugins_

#### 2. `env`
* We also will be using the `env` presets
    - This gives us access to `es2015`, `es2016`, and `es2017` preset
    - This gives us access to ES6 and ES7 (and future...) JavaScript stuff like:
        + const
        + let
        + import
        + arrow functions
        + rest and spread operators

### Install stuff we need
* We will install 3 things:

1. Babel
2. `env` preset
3. `react` preset

* After installing we'll start using our new commands inside the Terminal

#### 1. Global install babel-cli
`$ npm i -g babel-cli` (we already did this)

* After installing we'll have access to a new command called **babel**
* This gives a command line interface to using the babel compiler (but it does not come with any of those features - ie ES6, ES7 or JSX support)

## Check if babel was successfully installed
`$ babel --help`

* A bunch of info should appear in Terminal
* If you see that info, babel was successfully installed

## Now install react and env dependencies
* They will be installed locally in our project
* They do not give us access to any command like `react` or `env` but instead we just need their code to live in our project so `babel-cli` can take advantage of it and use it to transform JSX into those `createElement()` calls

## Create `package.json` with npm
* We already have our `package.json` created so we don't need to do this
* I include it here so you remember to do this for future projects
    - `-y` flag avoids us having to answer all the questions

`$ npm init -y`

* Now we have a brand new `package.json` file

## Install our project dependencies (our 2 presets)
`$ npm i babel-preset-react babel-preset-env`

* We just added a new `dependencies` section inside our `package.json`

`package.json`

```
// MORE CODE

"dependencies": {
    "babel-preset-env": "^1.7.0",
    "babel-preset-react": "^6.24.1"
  }

// MORE CODE
```

### What is babel-preset-env?
* http://babeljs.io/env
* Instead of continuing yearly presets, the team recommends using `babel-preset-env`
* By default, it has the same behavior as previous presets to compile ES2015+ to ES5

### dependencies and dev-dependensies
* You'll see the dependency name and it's version
* This little bit of information will enable us to easily reinstall all of our app dependencies for the project, as we add them they will grow and we can also have a dev-dependencies section which we'll see in a bit

#### sub dependencies
* We installed 2 dependencies but a bunch of sub-dependensies were also installed because our dependencies have their own dependensies, they have their own `package.json` files inside `node_modules`
    - This means when you install one dependency it can create the installation of dozens of other dependent packages
* We never have to go inside `node_modules` as it is just a generated folder with generated code and we will be able to delete and reinstall it based on just our `package.json` **dependencies** information

### package-lock.json
* This file was also generated when we ran our install
* We will never manually change `package-lock.json`
    - Open it up
    - It is an autogenerated file
    - It just lists out all the dependencies we saw in `node_modules` and their specific version numbers that are used and it shows were it got that package
    - This is a very useful file for npm "behind the scenes"
        + It makes sure that the code we are downloading is actually what is is supposed to be
        + It also prevents any sort of issues if libraries break, we can make sure that we are always using the specific version we specified
            * This will allow us to make sure we are always resolving the exact same dependencies regardless of whether we are installing this locally on production, on a different machine
        + Never change `package-lock.json` as it will change automatically as we change our dependencies

## yarn.lock
* **note** Remove `yarn.lock` (_could cause problems so let's just remove it since we aren't using yarn_)
* We are using npm not yarn so we can safely remove `yarn.lock`

### Difference between global npm and local npm installs
* Global are places in a location all projects can access `~/node_modules`
* Non global get installed in our project's `node_modules` and placed in the `package.json` as a **dependency** or a **dev-dependency**

## Now we can use babel!
* The goal is to create our file with modern JavaScript and have babel transpile it into another file for us automatically

## We will have a new folder `src`
* We will create this in the root of our react app
* This is where we will type out all of the react code that will make up our app

### New file - `src/app.js`
* This file will contain our JSX
* `scripts/app.js` will be an autogenerated file that will contain all of the other babel transformations

`$ mkdir src && touch src/app.js`

* This is the file `src/app.js` that will have our `JSX`

`src/app.js`

```
console.log('app.js is loading');

// JSX - JavaScript XML
const template = <p>I am JSX. Nice to meet you</p>;
const appRoot = document.getElementById('root');
ReactDOM.render(template, appRoot);
```

* And we will use `babel` to transpile the ES5 JavaScript into `public/app.js` using this command:

`$ babel src/app.js --out-file=public/scripts/app.js --presets=env,react`

* This will save us from copy and pasting code from one file into another file
* This means we'll maintain JSX code and all ES5 browser safe code will be maintained behind the scenes

## Let's analyze that command
`$ babel SOURCE/INPUT OUTPUT PRESETS`

* We start out with the path to our file `src/app.js`
    - `src/app.js` points to our source `React` code (using `JSX`)
* Then our next argument is the path to the output file `--out-file=public/scripts/app.js` (now whenever we run this command the output file will get overwritten automatically)
    - `--out-file` points to the generated ES5 code location
* The 3rd argument is the presets we want to use
    - `--presets=env,react` points to the **presets** we're using

## Run the command
`$ babel src/app.js --out-file=public/scripts/app.js --presets=env,react`

* After running the code look into `public/scripts/app.js` and you'll see the ES5 code that was generated!
* But running this command everytime we want to update JSX would be tedious
    - So we can autoupdate using the `--watch` flag

#### --watch
* We want to constantly watch for our `JSX` changes and then it will automatically update our ES5 generated code on each **save**

`$ babel src/app.js --out-file=public/scripts/app.js --presets=env,react --watch`

* Make a change to `src/app.js` to see if it in fact, does change
    - Make sure `live-server` is running
    - Need to run it in a separate browser
        + `$ live-server public`

`src/app.js`

```
console.log('App.js is running');

// JSX - JavaScript XML
const template = <p>Does this really change?</p>;
const appRoot = document.getElementById('app');

ReactDOM.render(template, appRoot);
```

* The browser should update with `Does this really change?`
* View `pubic/scripts/app.js` and see that it did change on the save

`public/scripts/app.js`

```js
'use strict';

console.log('App.js is running');

// JSX - JavaScript XML
var template = React.createElement(
  'p',
  null,
  'Does this really change?'
);
var appRoot = document.getElementById('app');

ReactDOM.render(template, appRoot);
```

* If your public `app.js` looks similar to above, you now know that `babel` is transpiling `JSX` into ES5 JavaScript and the browser understands it

## Two iTerm tabs are better than one
* We'll run the **babel watch** in one tab watching for changes to our `JSX`

`$ babel src/app.js --out-file=public/scripts/app.js --presets=env,react --watch`

* And in the other tab we'll run our server using:

`$ live-server public`

* Make a change to your `JSX` or your HTML and watch how the web app updates
* Now our workflow has improved nicely

## `node_modules`
* You will never see `node_modules` in any github repo (or if you do, it was a developer mistake)
    - Since the folder and code inside it is autogenerated you can add it to a `.gitignore` file in your app root

## Autogenerate `node_modules` with all your app dependencies
`$ npm i` (or `$ npm install`)

## Delete `node_modules`
* Let's see what happens without `node_modules`
* I also delete `package-lock.json` for a clean delete

`$ rm -rf node_modules package-lock.json`

* Running the following:

`$ babel src/app.js --out-file=public/scripts/app.js --presets=env,react --watch`

## Houston we have a problem!
* Now we get an error because we no longer have `babel` or the **presets**

`$ npm i`

* This will read our `package.json` file and install all our dependencies
    - Run this again:

`$ babel src/app.js --out-file=public/scripts/app.js --presets=env,react --watch`

* And it works again!
