# ES6 Promises
* These Promises will allow us to do something after a long running task completes
  - An example of a "long running task"
    + Like setting data in the firebase Database

## Let's Explore the Promises API in isolation
* After we understand how it works we'll work with Promises in Firebase to do one thing when our set() call succeeds or when it fails

### Create a new file called `promises.js`

`src/playground/promises.js`

* It would run by default until we import it temporarily just to play around with Promises in isolation

`app.js`

```
// MORE CODE

// temp import firbase for testing
import './firebase/firebase';
import './playground/promises'; // import our playground file

const store = configureStore();

// MORE CODE
```

## The easiest way to explore the Promises API
* Just create our own Promise and start messing around with it
* We create a new Promise using the `new` keyword with the `Promise` constructor function
* When we create a new instance of Promise we need to pass in a function as an argument
  - Inside the passing in function block this is where we pass in our long running asynchronous task

```
const promise = new Promise(() => {
  // new long running asynchronous task
})
```

## Long running asynchronous tasks
* examples:
  - maybe we are making a request to a server
  - trying to trigger a firebase data change
  - we're looking for a file in a file system
  - we're trying to take a picture with a web cam
  - any sort of long running task
  - any sort of asynchronous JavaScript

### when the long running asynchronous task is done
* We go ahead and call one of 2 functions

1. resolve
2. reject

#### resolve
* depending on whether it went well 

#### reject
* depending on whether it did not go well 

```
const promise = new Promise((resolve, reject) => {
  // new long running asynchronous task
});
```

* resolve is when things went well and we got the data of what we were doing
* reject is when things went bad and we alert the person and here is the error

```
const promise = new Promise((resolve, reject) => {
  resolve('This is my resolved data');
});

```

* Above is a completely valid Promise that we can start using
* **note** Most of the time these Promises are going to be created for us
  - This means we really won't see this code a whole lot in our actual project
  - Code like this lives inside the Firebase library
  - What we will be doing is using a lot of Promises
    + Promises that get generated by method calls like `set()`

## When we do have a Promise how do we do something when it either success or fails
* To do that we have to access the Promise and we have to register some callbacks

```
// MORE CODE

const promise = new Promise((resolve, reject) => {
  resolve('This is my resolved data');
});

promise.then()

// MORE CODE
```

* `then()` lets us register a callback
* The callback will fire when (and if) the Promise resolves
  - And in this callback we will have access to any data that might have been passed to `resolve`

```
// MORE CODE

const promise = new Promise((resolve, reject) => {
  resolve('This is my resolved data');
});

promise.then(data => {
  console.log(data);
});

// MORE CODE
```

### At this point
1. We have created a Promise that resolves some data
2. We waited for things to complete
3. When they do complete we dump data to the screen

## View the browser
* You will see `This is my resolved data` in the console

## It works but it is not a very practical example
* We'll use JavaScript's `setTimeout()` method to force the Promise to wait a 2 seconds before it actually resolves
  - `setTimeout()` takes 2 arguments

1. callback
2. time to wait

```
setTimeout(() => {
 // run this
}, MILLISECONDS_TO_WAIT_BEFORE_RUNNING_CALLBACK);
```

## Now try this:
```
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('This is my resolved data');
  }, 2000);
});

promise.then(data => {
  console.log(data);
});

```

* Now you will see 2 seconds pass before we see the log statement in the browser console

```
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('This is my resolved data');
  }, 2000);
});

console.log('before');

promise.then(data => {
  console.log(data);
});

console.log('after');

```

* Now you'll most likely see the console show

```
before
after
This is my resolved data
```

## What is happening in the above output?
1. our first log runs and prints `before` to the screen
2. Then we attach something that says "hey, when that Promise completes go ahead and run this function" (log out the returned data) - but it won't sit here and wait for the Promise to complete because we already registered a callback so this will allow the program to move on
3. Then we print the `after` log
4. Then we sit and wait those 5 seconds, eventually the Promise does resolve and the callback will fire

* And this shows you Promises working and our asynchronous code in action
* Change the time to `5000` milliseconds (5 seconds) and you will more dramatically see what happens as it will wait 5 seconds before resolving the Promise

### This Promise technique will give us lots of power
* With firebase
  - We'll be able to fetch data and wait for the data to come back and do something with the data

### The same thing is true when writing data
* We can start the process of writing data
* And then do something when firebase says "yes the data was written successfully"

## What if I have 2 Promises with 2 different callbacks?
```
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('This is my resolved data');
  }, 2000);
});

console.log('before');

promise.then(data => {
  console.log('1', data);
});

promise.then(data => {
  console.log('2', data);
});

console.log('after');

```

* Now you'll see
```
before
after
1 This is my resolved data
2 This is my resolved data
```

* You can do anything with the data that you like

## Remember that Promises can be `resolved` or `rejected`
* **note** You can't `resolve` and `reject` a Promise
* **note** You can only `resolve` or `reject` a single time

## What happens if you do this:
```
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('This is my resolved data');
    resolve('This is my other resolved data');
  }, 2000);
});

console.log('before');

promise.then(data => {
  console.log('1', data);
});

console.log('after');
```

* When we run the above code you may think that the callback runs twice
  - But that would not be correct
  - Why?
    + Because the **Promises API** was not designed for this
    + Your Promise is **either** `resolved` or `rejected`
    + When it is `resolved` or `rejected` it can never be `resolved` or `rejected` again
    + This means the second `resolve` in the above fragment of code will be completely ignored
      * Run and you will see that is true because you never see `This is my other resolved data`

#### resolve() only takes a single argument
* It is important to note that you can only pass a single argument to `resolve`

```
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('This is my resolved data', 'other');
  }, 2000);
});

console.log('before');

promise.then(data, other => {
  console.log('1', data, other);
});

console.log('after');

```

* Above will give you an error `data is not defined`

## So then how do I resolve something with more than one piece of information?
* Just resolve an **object** 

```
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve({
      name: 'John Doe',
      age: 100,
    });
  }, 2000);
});

console.log('before');

promise.then(data => {
  console.log('1', data.age);
});

console.log('after');

```

* That will give you after it is resolved `100`

### If you want to get all that data back
```
// MORE CODE
promise.then(data => {
  console.log('1', data);
});

console.log('after');
```

* Will give you back after the Promise is resolved:

```
1 {name: "John Doe", age: 100}
```

## What happens when things go wrong?
* So far we asked for stuff and we got it
* What happens when things go wrong?

### This is when we use the `reject` to deal with errors
* `reject` follows the same rules as `resolve`
  - You can only call it a single time
  - You can only call it with a single argument

#
```
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    // resolve({
    //   name: 'John Doe',
    //   age: 100,
    // });
    reject('Houston, we have a problem!');
  }, 2000);
});

console.log('before');

promise.then(data => {
  console.log('1', data);
});

console.log('after');
```

* We comment out the resolve so it doesn't run
* Then we add our reject and pass it one argument which is a string that will tell us we have a problem
* We run the code and see an error `Uncaught (in promise) Houston, we have a problem!`
  - This gives us an uncaught JavaScript error

## But we don't want to have a gazillion JavaScript errors getting thrown
* That won't help us
* Instead, we want to do something specific when we get the error
  - Maybe we want to try the request again
  - Or Maybe show a message to the user

## How do we do something when our Promise gets rejected?
* We just add on a call to `.catch()`
  - `.catch()` is very similar to `.then()`
    + `.catch()` gets called with a single function
    + This function fires when the Promise rejects and we do get access to that error data so we can call it `error` (but we could call it anything we like)
    + Now in the callback function block we can do something with the error
      * I could try the request again
      * We could print the message to the user in the browser
      * For now, we'll just log it out

#
```
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    // resolve({
    //   name: 'John Doe',
    //   age: 100,
    // });
    reject('Houston, we have a problem!');
  }, 2000);
});

console.log('before');

promise
  .then(data => {
    console.log('1', data);
  })
  .catch(() => {
    console.log('Something went horribly wrong');
  });

console.log('after');

```

* Now we see `Something went horribly wrong` in the browser console

### A nicer way to show the error
```
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    // resolve({
    //   name: 'John Doe',
    //   age: 100,
    // });
    reject('Houston, we have a problem!');
  }, 2000);
});

console.log('before');

promise
  .then(data => {
    console.log('1', data);
  })
  .catch(error => {
    console.log('error: ', error);
  });

console.log('after');

```

* That will output `error: Houston, we have a problem!`

## Eslint won't like this syntax and prefers you to fire an error like this:
```
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    // resolve({
    //   name: 'John Doe',
    //   age: 100,
    // });
    reject(new Error('Houston, we have a problem!'));
  }, 2000);
});

console.log('before');

promise
  .then(data => {
    console.log('1', data);
  })
  .catch(error => {
    console.log('error: ', error);
  });

console.log('after');

```

* That will show this:

![proper Promise error](https://i.imgur.com/6pA0KAA.png)

## Alternatives to the Promise syntax
* You will see lots of alternatives to the Promise syntax

### .then() can take 2 arguments (2 functions)
* And you can use this in lieu of `.catch()`
* So we remove .catch() and pass in another function and pass it our error data (we'll call it `error`)

```
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    // resolve({
    //   name: 'John Doe',
    //   age: 100,
    // });
    reject(new Error('Houston, we have a problem!'));
  }, 2000);
});

console.log('before');

promise.then(
  data => {
    console.log('1', data);
  },
  error => {
    console.log(error);
  }
);

console.log('after');

```

* And we get the same error in the console as before even though we never set up the `catch()` method call

## I show it here in case you see it on stackoverflow but it is NOT RECOMMENDED
* It is more confusing and not as straight forward as using `.catch()`
* then() and catch() makes more sense and easier to follow the steps

## Going to put the code back to using `.catch()`
```
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    // resolve({
    //   name: 'John Doe',
    //   age: 100,
    // });
    reject(new Error('Houston, we have a problem!'));
  }, 2000);
});

console.log('before');

promise
  .then(data => {
    console.log('1', data);
  })
  .catch(error => {
    console.log(error);
  });

console.log('after');

```

## Note - 99% of the time when we work with Promises
* We will work with the `then()` and `catch()`
* Very rarely will we be creating the Promise with the new keyword and the Promise constructor
* Most of the time the Promises will be created by the library you are using
  - For example:
    + A library like Firebase
    + When we are using Firebase we are not going to be create Promises explicitly but instead we'll attach handlers
      * Things to run when the Promise either `resolves` or is `rejects`

## Now let's do this for our firebase.js file
* We'll remove the import for the promises.js file in app.js
* And inside of `firebase.js`

### We want to attach a `then()` and `catch()` method call to one of our Promises
* But where is our Promise?
* Where exactly should we be calling `then()` and `catch()` on?

## Recap
* We learned about Promises
* Promises are a way to sync up our asynchronous operations
* If we have a really long running asynchronous task we want to do something when it completes and we can use Promises to get that done
* We just created a dummy Promise that waits 5 seconds
* But behind the scenes Firebase has a much more complex setup
  - It will look to see if the data was actually written
  - If the server could be connect to
  - All sorts of stuff goes into the Firebase Promise
* We had an existing Promise and we tried to do something either if it resolves or rejects
  - If we want to do something when the Promise resolves we call `then()` on the Promise passing in a callback function
  - We then get access to the data and we can then do something with it
  - If we want to add a handler if the Promise rejects all we do is call catch, we pass in a function, this function gets called if an error does occur, we get access to the error and we can do something with it

## Next - User Promises directly inside our firebase file 
