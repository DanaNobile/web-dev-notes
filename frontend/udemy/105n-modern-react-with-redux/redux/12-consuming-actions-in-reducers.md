# Consuming Actions in Reducers
In the last section we fleshed out our Action Creator `selectBook` by return an `action` from it with a **type** and a **payload**

```
export function selectBook(book) {
  return {
    type: 'BOOK_SELECTED',
    payload: book
  };
}
```

![diagram](https://i.imgur.com/X3pIsG2.png)

We are now at the `Action automatically sent to all reducers`

* This is possible because we wired up our BookList as a Container, the result of the Action Creator is being automatically sent to the list of all of our `reducers`

## Last Step - Create our ActiveBook Reducer
Create a new file `src/reducers/ReducerActiveBook.js`

### arguments to reducers
All reducers get two arguments

1. The current state (`state`)
2. `action`

```
export default function(state, action) {

}
```

**note** `reducers` are only ever called when an `action` occurs (_the `state`, on the other hand, is a little more nebulous/confusing_)

## state in reducer
`State` argument is not Application `state`, only the `state` this `reducer` is responsible for

### What do we mean by this?
```
const rootReducer = combineReducers({
  books: BooksReducer
});
```

`BooksReducers` is only responsible to provide value for `books` key. The `state` that gets passed as an argument for that `BooksReducer` is only the `state` that was previously generated by the `BooksReducer` (So the same `state` that is being produced by these `reducers`) is flowing back into it whenever an action occurs

```
export default function(state, action) {
  state += 1
}
```

**note** Simple example above (just trying to give an idea how `state` works with `reducers`) Assume that state is just a number (it is really an object) but let's say it was 1, the next time it came in it would already be 1 and the same state comes in and then it gets updated to 2 and then the next time 3... Rinse and repeat. When `state` gets updated it is NOT the Application `state`

* Our `reducer` is going to get called whenever an action is **dispatched** by our Application
* This means our `reducer` will be called all the time
* Lots of times when the `action` doesn't concern any particular `reducer` at any time so to handle a case where the `action` is **dispatched** that we don't care about we really need a **base case** to return the **current state** (_in other words if we don't care about the **current action** just pass the `state` back through_)

## The case where we DON'T CARE about the `action`
`src/reducers/ReducerActiveBook.js`

```
export default function(state, action) {
  return state;
}
```

## The case were we DO CARE about the `action`

**note** Most Redux `reducers` are set up JavaScript `switch` statements where the `switch` statement is going to look at the `action` **type** and if it is one that we care about, we'll return a new `state`

`src/reducers/ReducerActiveBook.js`

```
export default function(state, action) {
  switch(action.type)  {
    case 'BOOK_SELECTED':
      return action.payload
  }
  
  return state;
}
```

I our switch statment we only care about the `BOOK_SELECTED` case and if that is the action.type, then we'll return `action.payload` which is the `selectedBook`

## App first boots up
We need to handle the case when our Application first boots up and no book is immediately selected, and if that happens and the user hasn't clicked on it we just `return state`

```
export default function(state, action) {
  switch(action.type)  {
    case 'BOOK_SELECTED':
      return action.payload
  }
  
  return state; // we just return state here when the Application 
                // first boots up
}
```

But right now our `reducer` would return `undefined`. Redux won't allow us to return `undefined` from a `reducer`. It will throw an error

**rule** We must ALWAYS return a non-`undefined` value

## How can we handle this case?
We will default the value of the `state` argument to `null`

* This is ES6 syntax which allows us to give our function arguments default values

```
export default function(state = null, action) {
  switch(action.type)  {
    case 'BOOK_SELECTED':
      return action.payload
  }

  return state;
}
```

### Review
Our reducer is looking good

If the action has a type of BOOK_SELECTED we'll return the book that was selected (action.payload)
If the action is anything else we just return the current state

#### Here's an example of what not to do:

**important** We should never mutate our current state to produce a new version of the state. The object that we return from our reducer must always be 100% fresh and clean

`src/reducers/ReducerActiveBook.js`

```
export default function(state = null, action) {
  switch(action.type)  {
    case 'BOOK_SELECTED':
      // DON'T DO THIS!!!
      state.title = book.title
  }

  return state;
}
```

Our reducers need to be connected into the `combineReducers()`

`src/reducers/index.js`

```
import { combineReducers } from 'redux';
import BooksReducer from './ReducerBooks';

const rootReducer = combineReducers({
  books: BooksReducer
});

export default rootReducer;

```

### Import our ActiveBook reducer
```
import { combineReducers } from 'redux';
import BooksReducer from './ReducerBooks';
import ActiveBook from './ReducerActiveBook'; // add this line

const rootReducer = combineReducers({
  books: BooksReducer
});

export default rootReducer;
```

### Add ActiveBook to combineReducers
As another piece of `state`

```
import { combineReducers } from 'redux';
import BooksReducer from './ReducerBooks';
import ActiveBook from './ReducerActiveBook';

const rootReducer = combineReducers({
  books: BooksReducer,
  activeBook: ActiveBook
});

export default rootReducer;
```

**note** Any `key` we provide to our `combineReducers()` ends up as a `key` on our global `state` (_Application `state`_)

![diagram](https://i.imgur.com/e2MLn3g.png)

* We created a reducer that caught the **BOOK_SELECTED** `action` and returned the payload
* The `selectedBook` will now end up as the value for `activeBook` on our `state`

### Next
Verify that we set everything up correctly
